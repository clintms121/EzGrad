"""
Class recommendation algorithm for EzGrad.

Algorithm overview
------------------
1.  Load all courses for the chosen degree from degree_courses.json.
2.  Load prerequisite data from prerequisites.json (generated by
    backend/data/parse_courses.py from the RSU catalog).
3.  Filter out already-completed courses.
4.  Iteratively build semesters:
      a. Find every remaining course whose prerequisites are ALL satisfied
         (both hard prerequisites and OR-group prerequisites).
      b. Sort that "ready" pool by difficulty (lowest first) so students
         ease into harder material.
      c. Pack courses into the current semester up to max_hours.
      d. Overflow courses wait for the next semester.
      e. Repeat until all courses are scheduled.
5.  Return a structured semester plan with per-course metadata.

Prerequisite schema (prerequisites.json)
-----------------------------------------
Each course entry can have:

  "prerequisites":     ["DEPT NNN", ...]
      ALL of these must have been completed (or scheduled in a prior
      semester) before this course becomes available.

  "prerequisites_any": [
      ["DEPT AAA", "DEPT BBB"],   ← group 1 – need at least ONE of these
      ["DEPT CCC", "DEPT DDD"],   ← group 2 – need at least ONE of these
      ...
  ]
      For each group, at least ONE course must have been completed/
      scheduled in a prior semester.  This represents catalog language
      like "BIOL 1114, BIOL 1134, or BIOL 1144" (any one satisfies).

Courses absent from prerequisites.json receive safe defaults:
    credit_hours = 3,  difficulty = 3,  prerequisites = [],  prerequisites_any = []

To regenerate prerequisites.json from the RSU catalog run:
    python backend/data/parse_courses.py
"""

import json
import os

# ---------------------------------------------------------------------------
# Data loading
# ---------------------------------------------------------------------------

_DATA_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'data')


def _load_json(filename: str) -> dict:
    path = os.path.join(_DATA_DIR, filename)
    with open(path, 'r') as f:
        return json.load(f)


def _load_prereq_data() -> dict:
    """Load prerequisites.json and strip non-course metadata keys."""
    data = _load_json('prerequisites.json')
    data.pop('_metadata', None)
    data.pop('_PLACEHOLDER_INSTRUCTIONS', None)
    return data


# ---------------------------------------------------------------------------
# Course metadata helpers
# ---------------------------------------------------------------------------

_DEFAULTS = {
    "name":              None,
    "credit_hours":      3,
    "difficulty":        3,
    "prerequisites":     [],
    "prerequisites_any": [],
}


def _course_info(code: str, prereq_data: dict) -> dict:
    """
    Return metadata for a course, falling back to safe defaults for any
    field not present in prerequisites.json.
    """
    entry = prereq_data.get(code, {})
    return {
        "name":              entry.get("name") or code,
        "credit_hours":      entry.get("credit_hours",      _DEFAULTS["credit_hours"]),
        "difficulty":        entry.get("difficulty",        _DEFAULTS["difficulty"]),
        "prerequisites":     entry.get("prerequisites",     _DEFAULTS["prerequisites"]),
        "prerequisites_any": entry.get("prerequisites_any", _DEFAULTS["prerequisites_any"]),
    }


# ---------------------------------------------------------------------------
# Prerequisite readiness check
# ---------------------------------------------------------------------------

def _is_ready(course: str, prereq_data: dict, scheduled: set[str]) -> bool:
    """
    Return True if every prerequisite for *course* is already in *scheduled*.

    Two conditions must both hold:
      1. Every code in prerequisites is in scheduled.
      2. For every group in prerequisites_any, at least one code is in scheduled.

    Prerequisite codes that do not appear in the degree program (or in
    the catalog at all) are treated as satisfied — they represent
    external requirements the student is assumed to handle separately.
    """
    info = _course_info(course, prereq_data)

    for prereq in info["prerequisites"]:
        if prereq not in scheduled:
            return False

    for group in info["prerequisites_any"]:
        if not any(p in scheduled for p in group):
            return False

    return True


# ---------------------------------------------------------------------------
# Core scheduling algorithm
# ---------------------------------------------------------------------------

def _build_semester_plan(
    degree_courses: list[str],
    prereq_data: dict,
    completed_courses: list[str],
    max_hours: int,
) -> list[list[str]]:
    """
    Return a list of semesters (each a list of course codes) covering
    every un-completed course in degree_courses while respecting
    prerequisite ordering and the per-semester credit-hour cap.

    Ordering rules:
      - A course becomes available once all its prerequisites are
        satisfied (see _is_ready).
      - Within an available pool, courses are sorted by difficulty
        (ascending) so lighter courses come first.
      - Courses are packed greedily into the semester up to max_hours.
      - Any course that does not fit waits for the next semester.
      - If the hour cap prevents even the lightest available course
        from fitting, that course is force-added to avoid an infinite loop.
    """
    completed_set = set(completed_courses)
    remaining: set[str] = {c for c in degree_courses if c not in completed_set}
    scheduled: set[str] = set(completed_set)
    semesters: list[list[str]] = []

    while remaining:
        # Determine which courses have all prerequisites satisfied.
        ready = sorted(
            (c for c in remaining if _is_ready(c, prereq_data, scheduled)),
            key=lambda c: (_course_info(c, prereq_data)["difficulty"], c),
        )

        if not ready:
            # Circular dependency or prerequisite outside the degree plan.
            # Emit all remaining courses in one final block so the plan
            # always terminates.
            semesters.append(sorted(remaining))
            break

        current_semester: list[str] = []
        current_hours: int = 0
        overflow: list[str] = []

        for course in ready:
            hours = _course_info(course, prereq_data)["credit_hours"]
            if current_hours + hours <= max_hours:
                current_semester.append(course)
                current_hours += hours
                scheduled.add(course)
                remaining.discard(course)
            else:
                overflow.append(course)

        if not current_semester and overflow:
            # Hour cap is tighter than the smallest available course.
            # Force-add the lightest one to prevent an infinite loop.
            lightest = min(
                overflow,
                key=lambda c: _course_info(c, prereq_data)["credit_hours"],
            )
            current_semester.append(lightest)
            scheduled.add(lightest)
            remaining.discard(lightest)

        semesters.append(current_semester)

    return semesters


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

def recommend(
    degree: str,
    completed_courses: list[str] | None = None,
    max_hours_per_semester: int = 15,
) -> dict:
    """
    Generate a semester-by-semester course recommendation plan.

    Parameters
    ----------
    degree : str
        Degree program name.  Must match a key in degree_courses.json
        (case-sensitive, e.g. "Accounting, A.A.").
    completed_courses : list[str], optional
        Course codes the student has already passed
        (e.g. ["ENGL 1113", "MATH 1513"]).  Defaults to [].
    max_hours_per_semester : int
        Maximum credit hours the student wants per semester.
        Defaults to 15.

    Returns
    -------
    dict
        {
          "degree": str,
          "total_courses_in_degree": int,
          "completed_count": int,
          "remaining_count": int,
          "semesters_to_graduate": int,
          "plan": [
            {
              "semester": int,
              "total_hours": int,
              "courses": [
                {
                  "code": str,
                  "name": str,
                  "credit_hours": int,
                  "difficulty": int,          # 1–5
                  "prerequisites": [str],
                  "prerequisites_any": [[str]] # present only when non-empty
                },
                ...
              ]
            },
            ...
          ]
        }
        On error, returns {"error": str}.
    """
    completed_courses = completed_courses or []

    degree_data  = _load_json('degree_courses.json')
    prereq_data  = _load_prereq_data()

    if degree not in degree_data:
        return {"error": f"Degree '{degree}' not found in course catalog."}

    degree_courses: list[str] = degree_data[degree]
    degree_set     = set(degree_courses)
    completed_set  = set(completed_courses)
    completed_in_degree = [c for c in completed_courses if c in degree_set]

    semester_lists = _build_semester_plan(
        degree_courses,
        prereq_data,
        completed_courses,
        max_hours_per_semester,
    )

    plan = []
    for i, semester_courses in enumerate(semester_lists):
        courses_detail = []
        total_hours = 0
        for code in semester_courses:
            info = _course_info(code, prereq_data)
            total_hours += info["credit_hours"]
            course_entry: dict = {
                "code":          code,
                "name":          info["name"],
                "credit_hours":  info["credit_hours"],
                "difficulty":    info["difficulty"],
                "prerequisites": info["prerequisites"],
            }
            # Only include prerequisites_any when it carries data
            if info["prerequisites_any"]:
                course_entry["prerequisites_any"] = info["prerequisites_any"]
            courses_detail.append(course_entry)

        plan.append({
            "semester":    i + 1,
            "total_hours": total_hours,
            "courses":     courses_detail,
        })

    remaining_count = len([c for c in degree_courses if c not in completed_set])

    return {
        "degree":                  degree,
        "total_courses_in_degree": len(degree_courses),
        "completed_count":         len(completed_in_degree),
        "remaining_count":         remaining_count,
        "semesters_to_graduate":   len(plan),
        "plan":                    plan,
    }
